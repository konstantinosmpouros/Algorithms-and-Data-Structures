# Lance and Williams Hierarchical Clustering

## Σκεπτικο επίλυσης
προκειμενου να λυσουμε το προβλημα φτιαχνουμε μια κλαση με ονομα Cluster οπου θα δημιουργησουμε για καθε εναν αριθμο στην αρχη απο ενα object και μεσα θα περιεχει μια λιστα οπου θα μπει ο καθε αριθμος. Στην πορεια καθως θα συγχωνευουμε objects μεταξυ τους θα ενωνουμε τις λιστες τους και θα τις κανουμε και sort. Αρχικα δημιουργουμε καποιες λιστες που θα μας βοηθησουν να κανουμε ολους τους υπολογισμους οι οποιες ειναι: <br>
1. all_clusters: Μια λιστα που θα φυλοξενη ολα τα objects τυπου Cluster
2. distances: Μια λιστα 2D οπου θα περιεχει ολες τις πιθανες αποστασεις των objects που φτιαξαμε.
3. result: Θα κανουμε σε αυτη την λιστα σε καθε merge 2 object που κανουμε το αποτελεσμα που θελουμε να τυπωσουμε με την σωστη συνταξη.<br>

Η λογικη παει ως εξεις:
Στην αρχη δημιουργουμε μια λιστα οπου θα εχει μεσα ολα τα Objects που θα φτιαξουμε και κανουμε αρχικα sort ολα τα objects μεσα σε αυτην με αποτελεσμα να παρουμε την ακολουθη λιστα: 

[1]<br>
[2]<br>
[4]<br>
[6]<br>
[7]<br>
[10]<br>
[12]<br>
[19]<br>
[20]<br>
[25]<br>

Οταν δημιουργουμε τον "πινακα" distances οπου θα ειναι n*n οπου n το ποσα objects φτιαξαμε θα βαλουμε μεσα παντου μια πολυ μεγαλη τιμη οπως το 99999. Εχοντας στην αρχη τον ακολουθο πινακα:

[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>
[99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999, 99999]<br>


Στην αρχη θα παμε να ανανεωσουμε τον πινακα αυτον βαζοντας στην καθε θεση την σωστη αποσταση που στην αρχη θανε η διαφορα τον αριθμων που εχει το καθε cluster αλλα στις θεσης που σηματοδοτη την αποσταση ενως cluster με τον εαυτο του θα το αφησουμε 99999. Εχοντας δηλαδη αυτον τον πινακα:<br>

[99999, 1.0, 3.0, 5.0, 6.0, 9.0, 11.0, 18.0, 19.0, 24.0]<br>
[1.0, 99999, 2.0, 4.0, 5.0, 8.0, 10.0, 17.0, 18.0, 23.0]<br>
[3.0, 2.0, 99999, 2.0, 3.0, 6.0, 8.0, 15.0, 16.0, 21.0]<br>
[5.0, 4.0, 2.0, 99999, 1.0, 4.0, 6.0, 13.0, 14.0, 19.0]<br>
[6.0, 5.0, 3.0, 1.0, 99999, 3.0, 5.0, 12.0, 13.0, 18.0]<br>
[9.0, 8.0, 6.0, 4.0, 3.0, 99999, 2.0, 9.0, 10.0, 15.0]<br>
[11.0, 10.0, 8.0, 6.0, 5.0, 2.0, 99999, 7.0, 8.0, 13.0]<br>
[18.0, 17.0, 15.0, 13.0, 12.0, 9.0, 7.0, 99999, 1.0, 6.0]<br>
[19.0, 18.0, 16.0, 14.0, 13.0, 10.0, 8.0, 1.0, 99999, 5.0]<br>
[24.0, 23.0, 21.0, 19.0, 18.0, 15.0, 13.0, 6.0, 5.0, 99999]<br>

Στην συνεχεια θα παμε καθε φορα να κανουμε merge τα δυο closest cluster μεχρι να μεινουμε μονο με ενα cluster. Θα ψαχνουμε απλα και θα περνουμε απο τον πινακα distances τα δυο index απο το min value ας πουμε τα indexes αυτα minx , miny.

Αυτο σημαινει οτι αν το min value ειναι το distance[0][1] τοτε πρεπει να παρουμε το all_cluster[0], all_cluster[1] απο την λιστα all_clusters και να τα κανουμε merge. Τα κανουμε merge χωρις να αφαιρεσουμε ακομα τα δυο clusters απο την λιστα all_cluster και σημαντικο ειναι να κανουμε sort τα integers που εχουν μεσα τους.

Εχοντας κρατηση τα indexes απο τα clusters που θα κανουμε merge παμε αναλογα με το methode που πειραμε απο το input να υπολογισουμε τα distances με ολα τα αλλα clusters. Τα s, t του τυπου ειναι δηλαδη τα all_clusters[minx], all_clusters[miny]. 

Επειτα εφοσον εχουμε βρει τις αποστασης κανουμε delete τα all_clusters[minx], all_clusters[miny] αναλογος με πιο απο τα δυο indexes ειναι μεγαλυτερο γιατι αλλιως θα μετατοπιστης το αλλο. Διαγραφουμε πρωτα το μεγαλυτερο και μετα το μικροτερο. Το ιδιο κανουμε και στον πινακα distances οπου διαγραφουμε την γραμμη και την στηλη με το μεγαλυτερο index και μετα το μικροτερο.

Και τελος παμε και κανουμε insert το νεο cluster και τα νεα distances στην θεση που ηταν το μικρο index απο τα δυο clusters που καναμε merge. Ο λογος ειναι ο εξεις. Αν εχουμε την ακολουθει στηλε και θελουμε να κανουμε merge τα ακολουθα δυο clusters.

[1] <--<br>
[2]<br>
[4]<br>
[6]<br>
[7]<br>
[10] <--<br>
[12]<br>
[19]<br>
[20]<br>
[25]<br>

Τοτε το αποτελεσμα του merge θα ηταν το [1, 10] οποτε θα επρεπε να μπει στην θεση του μικροτερου απο τα δυο clusters για να διατηρηθει το sorting. Οποτε το αποτελεσμα θα ειναι το εξεις:

[1, 10]<br>
[2]<br>
[4]<br>
[6]<br>
[7]<br>
[12]<br>
[19]<br>
[20]<br>
[25]<br>

το ιδιο ακριβως κανουμε και στην 2D λιστα με τις αποστασεις. Διαγραφουμε τις παλιες αποστασεις και παμε στο μικροτερο index και βαζουμε τις νεες αποστασης αλλα με μια μικρη διαφορα.

Ας πουμε οτι η λιστα με τις νεες αποστασης ειναι η ακολουθη:<br>
dist = [1, 5, 6, 1, 2.5]

Και θελουμε να την κανουμε insert στο index 1. Πρεπει πρωτα να παμε και να βαλουμε και το στοιχειο 99999 στο σημειο που θα σηματοδοτη την αποσταση του νεου cluster με τον εαυτο του. Η θεση αυτη θα ειναι προφανος το index που παμε να το κανουμε insert δηλαδη dist.insert(1, 99999). Με αποτελεσμα θα βαλουμε στον πινακα το εξεις σαν στηλη και σαν γραμμη:

[1, 99999, 5, 6, 1, 2.5]

Επαναλλαμβανουμε το ιδιο πραγμα μεχρι να μεινουμε με ενα cluster.
